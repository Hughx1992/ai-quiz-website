/**
 * ÊàêÂ∞±Á≥ªÁªü - ËµõÂçöÊúãÂÖãÁ≠îÈ¢òÁ´ûËµõ
 * 
 * ÂäüËÉΩÁâπÊÄßÔºö
 * - ÊàêÂ∞±Â±ïÁ§∫ÂíåÂàÜÁ±ªÁ≠õÈÄâ
 * - ÂÆûÊó∂ÊàêÂ∞±ËøõÂ∫¶ËøΩË∏™
 * - ÊàêÂ∞±Ëß£ÈîÅÈÄöÁü•
 * - ÊàêÂ∞±ÁªüËÆ°Ê¶ÇËßà
 * - ‰∏éÁ≠îÈ¢òÁ≥ªÁªüÈõÜÊàê
 * - ËµõÂçöÊúãÂÖãÈ£éÊ†ºUI
 */

class AchievementSystem {
    constructor() {
        this.socket = null;
        this.achievements = [];
        this.userAchievements = [];
        this.currentUserId = null;
        this.currentFilter = 'all';
        this.notificationQueue = [];
        this.isProcessingNotifications = false;
        
        this.init();
    }

    async init() {
        try {
            // ÂàùÂßãÂåñSocket.IOËøûÊé•
            this.socket = io();
            
            // Ëé∑ÂèñÂΩìÂâçÁî®Êà∑ID
            await this.getCurrentUser();
            
            // Âä†ËΩΩÊàêÂ∞±Êï∞ÊçÆ
            await this.loadAchievements();
            
            // Âä†ËΩΩÁî®Êà∑ÊàêÂ∞±
            await this.loadUserAchievements();
            
            // ÂàùÂßãÂåñUIÁªÑ‰ª∂
            this.initializeUI();
            
            // ËÆæÁΩÆ‰∫ã‰ª∂ÁõëÂê¨Âô®
            this.setupEventListeners();
            
            // ËÆæÁΩÆSocket.IO‰∫ã‰ª∂ÁõëÂê¨
            this.setupSocketListeners();
            
            // ÂºÄÂßãÂ§ÑÁêÜÊàêÂ∞±ÈÄöÁü•
            this.processNotificationQueue();
            
            console.log('üèÜ ÊàêÂ∞±Á≥ªÁªüÂàùÂßãÂåñÂÆåÊàê');
        } catch (error) {
            console.error('‚ùå ÊàêÂ∞±Á≥ªÁªüÂàùÂßãÂåñÂ§±Ë¥•:', error);
        }
    }

    async getCurrentUser() {
        try {
            // Â∞ùËØï‰ªélocalStorageËé∑ÂèñÁî®Êà∑‰ø°ÊÅØ
            const savedUser = localStorage.getItem('currentUser');
            if (savedUser) {
                const user = JSON.parse(savedUser);
                this.currentUserId = user.id;
                return;
            }
            
            // Â¶ÇÊûúÊ≤°Êúâ‰øùÂ≠òÁöÑÁî®Êà∑‰ø°ÊÅØÔºåÁîüÊàê‰∏¥Êó∂Áî®Êà∑ID
            const tempUserId = localStorage.getItem('tempUserId') || this.generateTempUserId();
            localStorage.setItem('tempUserId', tempUserId);
            this.currentUserId = tempUserId;
        } catch (error) {
            console.error('Ëé∑ÂèñÁî®Êà∑‰ø°ÊÅØÂ§±Ë¥•:', error);
            this.currentUserId = this.generateTempUserId();
        }
    }

    generateTempUserId() {
        return 'temp_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    }

    async loadAchievements() {
        try {
            const response = await fetch('/api/achievements');
            if (!response.ok) throw new Error('Failed to load achievements');
            
            this.achievements = await response.json();
            console.log(`üìã Âä†ËΩΩ‰∫Ü ${this.achievements.length} ‰∏™ÊàêÂ∞±`);
        } catch (error) {
            console.error('Âä†ËΩΩÊàêÂ∞±Â§±Ë¥•:', error);
            this.achievements = this.getDefaultAchievements();
        }
    }

    async loadUserAchievements() {
        if (!this.currentUserId) return;
        
        try {
            const response = await fetch(`/api/user-achievements/${this.currentUserId}`);
            if (!response.ok) throw new Error('Failed to load user achievements');
            
            this.userAchievements = await response.json();
            console.log(`üèÖ Âä†ËΩΩ‰∫Ü ${this.userAchievements.length} ‰∏™Áî®Êà∑ÊàêÂ∞±`);
        } catch (error) {
            console.error('Âä†ËΩΩÁî®Êà∑ÊàêÂ∞±Â§±Ë¥•:', error);
            this.userAchievements = [];
        }
    }

    getDefaultAchievements() {
        return [
            {
                id: 'first_answer',
                name: 'ÂàùÊ¨°Á≠îÈ¢ò',
                description: 'ÂÆåÊàê‰Ω†ÁöÑÁ¨¨‰∏ÄÊ¨°Á≠îÈ¢ò',
                category: 'answer',
                rarity: 'bronze',
                condition: { type: 'answer_count', target: 1 },
                rewards: { points: 10, title: 'Êñ∞ÊâãÁ≠îÈ¢òËÄÖ' },
                icon: 'üéØ',
                isActive: true
            },
            {
                id: 'answer_master',
                name: 'Á≠îÈ¢òÂ§ßÂ∏à',
                description: 'Á¥ØËÆ°Á≠îÂØπ50ÈÅìÈ¢òÁõÆ',
                category: 'answer',
                rarity: 'gold',
                condition: { type: 'answer_count', target: 50 },
                rewards: { points: 100, title: 'Á≠îÈ¢òÂ§ßÂ∏à' },
                icon: 'üèÜ',
                isActive: true
            },
            {
                id: 'speed_demon',
                name: 'ÊûÅÈÄüÁ≠îÈ¢ò',
                description: 'Âú®5ÁßíÂÜÖÁ≠îÂØπ‰∏ÄÈÅìÈ¢òÁõÆ',
                category: 'speed',
                rarity: 'silver',
                condition: { type: 'answer_speed', target: 5 },
                rewards: { points: 25, title: 'ÊûÅÈÄüËÄÖ' },
                icon: '‚ö°',
                isActive: true
            },
            {
                id: 'perfectionist',
                name: 'ÂÆåÁæé‰∏ª‰πâËÄÖ',
                description: 'ÂçïÊ¨°Á≠îÈ¢òÂáÜÁ°ÆÁéáËææÂà∞100%',
                category: 'accuracy',
                rarity: 'gold',
                condition: { type: 'session_accuracy', target: 100 },
                rewards: { points: 50, title: 'ÂÆåÁæé‰∏ª‰πâËÄÖ' },
                icon: 'üíé',
                isActive: true
            },
            {
                id: 'night_owl',
                name: 'Â§úÁå´Â≠ê',
                description: 'Âú®Ê∑±Â§ú23:00-02:00ÊúüÈó¥Á≠îÂØπ10ÈÅìÈ¢òÁõÆ',
                category: 'time',
                rarity: 'silver',
                condition: { type: 'time_based', target: 10, timeRange: '23:00-02:00' },
                rewards: { points: 30, title: 'Â§úÁå´Â≠ê' },
                icon: 'üåô',
                isActive: true
            },
            {
                id: 'streak_master',
                name: 'ËøûËÉúÂ§ßÂ∏à',
                description: 'ËøûÁª≠Á≠îÂØπ5ÈÅìÈ¢òÁõÆ',
                category: 'streak',
                rarity: 'silver',
                condition: { type: 'correct_streak', target: 5 },
                rewards: { points: 40, title: 'ËøûËÉúÂ§ßÂ∏à' },
                icon: 'üî•',
                isActive: true
            }
        ];
    }

    initializeUI() {
        this.updateStats();
        this.renderAchievements();
        this.initializeCategories();
    }

    setupEventListeners() {
        // ÂàÜÁ±ªÊåâÈíÆÁÇπÂáª‰∫ã‰ª∂
        document.querySelectorAll('.achievement-category').forEach(button => {
            button.addEventListener('click', (e) => {
                this.filterByCategory(e.target.dataset.category);
            });
        });
    }

    setupSocketListeners() {
        this.socket.on('achievement-unlocked', (data) => {
            if (data.userId === this.currentUserId) {
                this.showAchievementNotification(data.achievement);
                this.addToNotificationQueue(data);
            }
        });
    }

    updateStats() {
        const totalAchievements = this.achievements.length;
        const unlockedAchievements = this.userAchievements.length;
        const unlockRate = totalAchievements > 0 ? Math.round((unlockedAchievements / totalAchievements) * 100) : 0;
        const totalPoints = this.userAchievements.reduce((sum, ua) => {
            const achievement = this.achievements.find(a => a.id === ua.achievementId);
            return sum + (achievement?.rewards?.points || 0);
        }, 0);

        this.animateNumber('total-achievements', totalAchievements);
        this.animateNumber('unlocked-achievements', unlockedAchievements);
        this.animateNumber('unlock-rate', unlockRate, '%');
        this.animateNumber('total-points', totalPoints);
    }

    animateNumber(elementId, targetValue, suffix = '') {
        const element = document.getElementById(elementId);
        if (!element) return;

        const startValue = parseInt(element.textContent) || 0;
        const duration = 1000;
        const startTime = performance.now();

        const animate = (currentTime) => {
            const elapsed = currentTime - startTime;
            const progress = Math.min(elapsed / duration, 1);
            
            const currentValue = Math.floor(startValue + (targetValue - startValue) * progress);
            element.textContent = currentValue + suffix;

            if (progress < 1) {
                requestAnimationFrame(animate);
            }
        };

        requestAnimationFrame(animate);
    }

    renderAchievements() {
        const grid = document.getElementById('achievement-grid');
        if (!grid) return;

        const filteredAchievements = this.getFilteredAchievements();
        
        grid.innerHTML = filteredAchievements.map(achievement => {
            const userAchievement = this.userAchievements.find(ua => ua.achievementId === achievement.id);
            const isUnlocked = !!userAchievement;
            
            return this.createAchievementCard(achievement, userAchievement, isUnlocked);
        }).join('');

        // Ê∑ªÂä†Âä®ÁîªÊïàÊûú
        this.addAchievementAnimations();
    }

    getFilteredAchievements() {
        if (this.currentFilter === 'all') {
            return this.achievements;
        }
        return this.achievements.filter(achievement => achievement.category === this.currentFilter);
    }

    createAchievementCard(achievement, userAchievement, isUnlocked) {
        const progress = this.calculateAchievementProgress(achievement);
        const rarity = achievement.rarity || 'bronze';
        
        return `
            <div class="achievement-card ${rarity} ${isUnlocked ? 'unlocked' : ''}" 
                 data-achievement-id="${achievement.id}"
                 onclick="achievementSystem.showAchievementDetails('${achievement.id}')">
                
                <div class="achievement-header">
                    <div class="achievement-badge ${rarity} ${isUnlocked ? 'unlocked' : ''}">
                        ${achievement.icon || 'üèÜ'}
                    </div>
                    <div class="achievement-info">
                        <div class="achievement-title">${achievement.name}</div>
                        <div class="achievement-type">${this.getCategoryName(achievement.category)}</div>
                    </div>
                </div>
                
                <div class="achievement-description">${achievement.description}</div>
                
                ${progress < 100 ? `
                    <div class="achievement-progress">
                        <div class="achievement-progress-bar">
                            <div class="achievement-progress-fill" style="width: ${progress}%"></div>
                        </div>
                        <div class="achievement-progress-text">
                            <span>ËøõÂ∫¶</span>
                            <span>${progress}%</span>
                        </div>
                    </div>
                ` : ''}
                
                ${isUnlocked ? `
                    <div class="achievement-unlock-time">
                        Ëß£ÈîÅ‰∫é ${this.formatDate(userAchievement.unlockedAt)}
                    </div>
                ` : ''}
                
                ${achievement.rewards ? `
                    <div class="achievement-rewards">
                        ${achievement.rewards.points ? `<span class="reward-item points">+${achievement.rewards.points} ÁßØÂàÜ</span>` : ''}
                        ${achievement.rewards.title ? `<span class="reward-item">${achievement.rewards.title}</span>` : ''}
                    </div>
                ` : ''}
            </div>
        `;
    }

    calculateAchievementProgress(achievement) {
        if (!achievement.condition) return 0;
        
        const userAchievement = this.userAchievements.find(ua => ua.achievementId === achievement.id);
        if (userAchievement) return 100;
        
        // ËøôÈáåÂèØ‰ª•Ê†πÊçÆ‰∏çÂêåÁöÑÊù°‰ª∂Á±ªÂûãËÆ°ÁÆóËøõÂ∫¶
        // ÁõÆÂâçÁÆÄÂåñÂ§ÑÁêÜÔºåÂÆûÈôÖÂ∫îÁî®‰∏≠ÈúÄË¶ÅÊ†πÊçÆÁî®Êà∑Êï∞ÊçÆËÆ°ÁÆó
        return 0;
    }

    getCategoryName(category) {
        const categoryNames = {
            'answer': 'Á≠îÈ¢òÊàêÂ∞±',
            'streak': 'ËøûÁª≠ÊàêÂ∞±',
            'speed': 'ÈÄüÂ∫¶ÊàêÂ∞±',
            'accuracy': 'ÂáÜÁ°ÆÁéáÊàêÂ∞±',
            'time': 'Êó∂Èó¥ÊàêÂ∞±'
        };
        return categoryNames[category] || 'ÂÖ∂‰ªñÊàêÂ∞±';
    }

    addAchievementAnimations() {
        const cards = document.querySelectorAll('.achievement-card');
        cards.forEach((card, index) => {
            card.style.opacity = '0';
            card.style.transform = 'translateY(20px)';
            
            setTimeout(() => {
                card.style.transition = 'opacity 0.5s ease, transform 0.5s ease';
                card.style.opacity = '1';
                card.style.transform = 'translateY(0)';
            }, index * 100);
        });
    }

    initializeCategories() {
        // ÂàÜÁ±ªÊåâÈíÆÂ∑≤Âú®HTML‰∏≠ÂÆö‰πâÔºåËøôÈáåÂèØ‰ª•Ê∑ªÂä†È¢ùÂ§ñÁöÑÂàùÂßãÂåñÈÄªËæë
    }

    filterByCategory(category) {
        this.currentFilter = category;
        
        // Êõ¥Êñ∞ÊåâÈíÆÁä∂ÊÄÅ
        document.querySelectorAll('.achievement-category').forEach(button => {
            button.classList.remove('active');
        });
        document.querySelector(`[data-category="${category}"]`).classList.add('active');
        
        // ÈáçÊñ∞Ê∏≤ÊüìÊàêÂ∞±
        this.renderAchievements();
    }

    showAchievementDetails(achievementId) {
        const achievement = this.achievements.find(a => a.id === achievementId);
        const userAchievement = this.userAchievements.find(ua => ua.achievementId === achievementId);
        
        if (!achievement) return;
        
        // ÂàõÂª∫Ê®°ÊÄÅÊ°ÜÊòæÁ§∫ÊàêÂ∞±ËØ¶ÊÉÖ
        const modal = this.createAchievementModal(achievement, userAchievement);
        document.body.appendChild(modal);
        
        // ÊòæÁ§∫Ê®°ÊÄÅÊ°Ü
        setTimeout(() => {
            modal.classList.add('active');
        }, 100);
    }

    createAchievementModal(achievement, userAchievement) {
        const isUnlocked = !!userAchievement;
        const rarity = achievement.rarity || 'bronze';
        
        const modal = document.createElement('div');
        modal.className = 'achievement-modal';
        modal.innerHTML = `
            <div class="achievement-modal-content">
                <button class="achievement-modal-close" onclick="this.closest('.achievement-modal').remove()">√ó</button>
                
                <div class="achievement-header">
                    <div class="achievement-badge ${rarity} ${isUnlocked ? 'unlocked' : ''}" style="width: 80px; height: 80px; font-size: 2rem;">
                        ${achievement.icon || 'üèÜ'}
                    </div>
                    <div class="achievement-info">
                        <div class="achievement-title">${achievement.name}</div>
                        <div class="achievement-type">${this.getCategoryName(achievement.category)}</div>
                    </div>
                </div>
                
                <div class="achievement-description">${achievement.description}</div>
                
                ${achievement.condition ? `
                    <div class="achievement-condition">
                        <h4>Ëß£ÈîÅÊù°‰ª∂:</h4>
                        <p>${this.formatCondition(achievement.condition)}</p>
                    </div>
                ` : ''}
                
                ${achievement.rewards ? `
                    <div class="achievement-rewards">
                        <h4>Â•ñÂä±:</h4>
                        ${achievement.rewards.points ? `<span class="reward-item points">+${achievement.rewards.points} ÁßØÂàÜ</span>` : ''}
                        ${achievement.rewards.title ? `<span class="reward-item">${achievement.rewards.title}</span>` : ''}
                    </div>
                ` : ''}
                
                ${isUnlocked ? `
                    <div class="achievement-unlock-time">
                        Ëß£ÈîÅ‰∫é ${this.formatDate(userAchievement.unlockedAt)}
                    </div>
                ` : ''}
            </div>
        `;
        
        return modal;
    }

    formatCondition(condition) {
        switch (condition.type) {
            case 'answer_count':
                return `Á¥ØËÆ°Á≠îÈ¢ò ${condition.target} Ê¨°`;
            case 'correct_streak':
                return `ËøûÁª≠Á≠îÂØπ ${condition.target} ÈÅìÈ¢òÁõÆ`;
            case 'answer_speed':
                return `Âú® ${condition.target} ÁßíÂÜÖÁ≠îÂØπÈ¢òÁõÆ`;
            case 'session_accuracy':
                return `ÂçïÊ¨°Á≠îÈ¢òÂáÜÁ°ÆÁéáËææÂà∞ ${condition.target}%`;
            case 'time_based':
                return `Âú® ${condition.timeRange} ÊúüÈó¥Á≠îÂØπ ${condition.target} ÈÅìÈ¢òÁõÆ`;
            default:
                return 'ÂÆåÊàêÁâπÂÆöÊù°‰ª∂';
        }
    }

    showAchievementNotification(achievement) {
        const notification = this.createAchievementNotification(achievement);
        const container = document.getElementById('achievement-notification-container');
        if (!container) return;
        
        container.appendChild(notification);
        
        // Ê∑ªÂä†Âä®ÁîªÊïàÊûú
        setTimeout(() => {
            notification.style.animation = 'slideInRight 0.5s ease-out';
        }, 100);
        
        // Ëá™Âä®ÁßªÈô§ÈÄöÁü•
        setTimeout(() => {
            notification.style.animation = 'slideOutRight 0.5s ease-out';
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
            }, 500);
        }, 5000);
    }

    createAchievementNotification(achievement) {
        const notification = document.createElement('div');
        notification.className = 'achievement-notification';
        notification.innerHTML = `
            <div class="achievement-notification-header">
                <div class="achievement-notification-icon">üéâ</div>
                <div class="achievement-notification-title">ÊàêÂ∞±Ëß£ÈîÅ!</div>
            </div>
            
            <div class="achievement-notification-content">
                <div class="achievement-notification-badge">
                    ${achievement.icon || 'üèÜ'}
                </div>
                <div class="achievement-notification-name">${achievement.name}</div>
                <div class="achievement-notification-description">${achievement.description}</div>
            </div>
            
            ${achievement.rewards ? `
                <div class="achievement-notification-rewards">
                    ${achievement.rewards.points ? `<span class="reward-item points">+${achievement.rewards.points} ÁßØÂàÜ</span>` : ''}
                    ${achievement.rewards.title ? `<span class="reward-item">${achievement.rewards.title}</span>` : ''}
                </div>
            ` : ''}
            
            <div class="achievement-notification-actions">
                <button class="achievement-notification-btn" onclick="window.open('/achievements', '_blank')">Êü•ÁúãÊàêÂ∞±</button>
                <button class="achievement-notification-btn" onclick="this.closest('.achievement-notification').remove()">ÂÖ≥Èó≠</button>
            </div>
        `;
        
        return notification;
    }

    addToNotificationQueue(data) {
        this.notificationQueue.push(data);
    }

    processNotificationQueue() {
        if (this.isProcessingNotifications || this.notificationQueue.length === 0) {
            setTimeout(() => this.processNotificationQueue(), 1000);
            return;
        }
        
        this.isProcessingNotifications = true;
        const notification = this.notificationQueue.shift();
        
        // Â§ÑÁêÜÈÄöÁü•ÈÄªËæë
        console.log('Â§ÑÁêÜÊàêÂ∞±ÈÄöÁü•:', notification);
        
        this.isProcessingNotifications = false;
    }

    formatDate(dateString) {
        const date = new Date(dateString);
        return date.toLocaleString('zh-CN', {
            year: 'numeric',
            month: '2-digit',
            day: '2-digit',
            hour: '2-digit',
            minute: '2-digit'
        });
    }

    // Âà∑Êñ∞ÊàêÂ∞±Êï∞ÊçÆ
    async refreshAchievements() {
        try {
            await this.loadAchievements();
            await this.loadUserAchievements();
            this.updateStats();
            this.renderAchievements();
            
            // ÊòæÁ§∫Âà∑Êñ∞ÊàêÂäüÊèêÁ§∫
            this.showRefreshSuccess();
        } catch (error) {
            console.error('Âà∑Êñ∞ÊàêÂ∞±Â§±Ë¥•:', error);
            this.showRefreshError();
        }
    }

    showRefreshSuccess() {
        this.showToast('ÊàêÂ∞±Êï∞ÊçÆÂ∑≤Êõ¥Êñ∞', 'success');
    }

    showRefreshError() {
        this.showToast('Âà∑Êñ∞Â§±Ë¥•ÔºåËØ∑Á®çÂêéÈáçËØï', 'error');
    }

    showToast(message, type = 'info') {
        const toast = document.createElement('div');
        toast.className = `toast toast-${type}`;
        toast.textContent = message;
        toast.style.cssText = `
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: ${type === 'success' ? '#4CAF50' : type === 'error' ? '#f44336' : '#2196F3'};
            color: white;
            padding: 12px 24px;
            border-radius: 4px;
            z-index: 10000;
            animation: slideInDown 0.3s ease-out;
        `;
        
        document.body.appendChild(toast);
        
        setTimeout(() => {
            toast.style.animation = 'slideOutUp 0.3s ease-out';
            setTimeout(() => {
                if (toast.parentNode) {
                    toast.parentNode.removeChild(toast);
                }
            }, 300);
        }, 3000);
    }
}

// ÂÖ®Â±ÄÂáΩÊï∞
function refreshAchievements() {
    if (window.achievementSystem) {
        window.achievementSystem.refreshAchievements();
    }
}

// ÂàùÂßãÂåñÊàêÂ∞±Á≥ªÁªü
document.addEventListener('DOMContentLoaded', () => {
    window.achievementSystem = new AchievementSystem();
});

// ÂØºÂá∫ÊàêÂ∞±Á≥ªÁªüÁ±ªÔºà‰æõÂÖ∂‰ªñÈ°µÈù¢‰ΩøÁî®Ôºâ
if (typeof module !== 'undefined' && module.exports) {
    module.exports = AchievementSystem;
}